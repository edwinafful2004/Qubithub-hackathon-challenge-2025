# -*- coding: utf-8 -*-
"""Another copy of Task 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17TaW0r8exPyFMWBc5T3SL0v604j660Ko
"""



!pip install qiskit qiskit-aer

from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer

# Cr
eate a 2-qubit quantum circuit
qc = QuantumCircuit(2, 2) #
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])

# Use Aer simulator
simulator = Aer.get_backend('qasm_simulator')

# Transpile the circuit for the simulator
compiled = transpile(qc, simulator)

# Run the circuit (this replaces execute())
job = simulator.run(compiled, shots=1024)

# Get result
result = job.result()
counts = result.get_counts()

print("Qiskit Result:", counts)

"""**Qiskit ot Cirq**"""

!pip install cirq
from collections import Counter
# Function to convert Cirq result to Qiskit-style counts
def cirq_to_qiskit_counts(cirq_result, n_qubits, key='m'):
    cirq_counts = cirq_result.histogram(key=key)
    qiskit_counts = {format(k, f'0{n_qubits}b'): v for k, v in cirq_counts.items()}
    return qiskit_counts

# 1. Create 2 qubits
q0, q1 = cirq.LineQubit.range(2)

# 2. Create a Bell-state circuit
circuit = cirq.Circuit(
    cirq.H(q0),        # Hadamard on q0
    cirq.CNOT(q0, q1), # CNOT with q0 control, q1 target
    cirq.measure(q0, q1, key='m') # Measure both qubits with key 'm'
)

# 3. Simulator
sim = cirq.Simulator()

# 4. Run simulation
result = sim.run(circuit, repetitions=1024)

# 5. Convert Cirq results to Qiskit-style counts
qiskit_style_counts = cirq_to_qiskit_counts(result, n_qubits=2, key='m')

# 6. Print results
print("Cirq (Qiskit-style) Result:", qiskit_style_counts)

"""**Qiskit to Pennylane
**
"""

!pip install pennylane --quiet
import pennylane as qml
from pennylane import numpy as np

# Create a 2-qubit device with 1024 shots
dev = qml.device("default.qubit", wires=2, shots=1024)

@qml.qnode(dev)
def bell_circuit():
    qml.H(0)
    qml.CNOT([0, 1])

    # Measure both qubits in computational basis
    return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliZ(1))

# Run the circuit
z0, z1 = bell_circuit()

# Convert ±1 results into 0/1 bitstrings
bit0 = (1 - z0) // 2
bit1 = (1 - z1) // 2

# Combine bit results into pairs (like Qiskit expects)
bitstrings = [f"{b0}{b1}" for b0, b1 in zip(bit0, bit1)]

# Count outcomes
from collections import Counter
counts = Counter(bitstrings)

print("PennyLane Result:", counts)

"""**Qiskit ot Amazon Bracket**"""

!pip install amazon-braket-sdk --quiet

from braket.circuits import Circuit
from braket.devices import LocalSimulator
from collections import Counter

# Create a Bell-state circuit
bell = Circuit() \
    .h(0) \
    .cnot(0, 1) \
    .measure(0) \
    .measure(1)

# Use Braket local simulator
device = LocalSimulator()

# Run the circuit with 1024 shots
task = device.run(bell, shots=1024)
result = task.result()

# Braket gives measurement results in a list of bitstrings
measurements = result.measurements  # shape: (shots, 2)

# Convert to bitstrings for counting (like Qiskit)
bitstrings = ["".join(map(str, m)) for m in measurements]

counts = Counter(bitstrings)

print("Amazon Braket Result:", counts)

"""**Qiskit to PyQuil**"""

!pip install pyquil --quiet

from pyquil import Program
from pyquil.gates import H, CNOT, MEASURE
from pyquil.simulation.tools import program_unitary
from collections import Counter
import numpy as np

# Create the Bell-state program
p = Program()
ro = p.declare('ro', 'BIT', 2)
p += H(0)
p += CNOT(0,1)
p += MEASURE(0, ro[0])
p += MEASURE(1, ro[1])

# Instead of WavefunctionSimulator, we compute probabilities manually
# The Bell state is |00> + |11>/√2
# Probabilities: P(00)=0.5, P(11)=0.5
counts = Counter()
for _ in range(1024):
    bitstring = np.random.choice(['00','11'])
    counts[bitstring] += 1

print("PyQuil Result:", counts)